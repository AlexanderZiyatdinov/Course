# Рекурсия. Итераторы. Генераторы. Декораторы.

## Рекурсия

> "Я хочу, чтоб мне давали монетку каждый раз, когда я хочу, чтобы мне дали монетку"

**Рекурсия** — вызов функции из неё же самой, непосредственно (простая рекурсия) или через другие функции (сложная или косвенная рекурсия), например, функция `f` вызывает функцию `g`, а функция `g` — функцию `f`.

Рекурсия может использоваться для решения разного рода задач. Например для вычисления `f(n)` нам может понадобится вычислить значение `f(n-1`). Можно сказать, что частью вычисления такой функции будет вычисление этой же функции.

Итак, функция является **рекурсивной**, если она обращается сама к себе прямо или косвенно (через другие функции). Заметим, что при косвенном обращении все функции в цепочке – рекурсивные.

Например, мы хотим посчитать с помощью рекурсии n-ое число Фибоначчи:

```python
def fib(n):
    if n in 0, 1:
        return 1
    return fib(n - 1) + fib(n - 2)
```

Пожалуйста, при вычислении `fib(n)` мы вычислим `fib(n - 1)` и `fib(n - 2)` и т. д. до тех пор, пока мы не дойдем до случаев `fib(0)` и `fib(1)` - это особые случаи, которые необходимо всегда учитывать при вычислении рекурсивной функции, иначе мы просто уйдем в бесконечный цикл.

Однако, Python спасет нас, если мы что-то вдруг напутали в вычислении функции и стали устремляться в бесконечность:

```python
def foo():
    return foo()

foo()

# Выведет:
RecursionError: maximum recursion depth exceeded
```

**Важно: **При вызове рекурсивной функции стоит помнить, что сначала выполнится самая последняя вызванная функция, потом предпоследняя и т. д. до первоначально вызванной, вот пример:

```python
def foo(n):
    if n > 1:
        foo(n - 1)
    print(n)
        
foo(5)

# Выведет:
1
2
3
4
5

# Получился некоторый стек вызовов:
f(5) -> f(4) -> f(3) -> f(2) -> f(1)
Выполнилось: f(1)
Выполнилось: f(2)
Выполнилось: f(3)
Выполнилось: f(4)       
Выполнилось: f(5) 
```

## Итераторы

![img](https://docs.inftec.ch/download/attachments/53411995/Screenshot%202015-10-09%2012.36.53.png?version=1&modificationDate=1444393845000&api=v2)

### Утиная типизация

Перед тем, как начать говорить про Итераторы и Генераторы, немного поговорим про так называемую **Утиную типизацию**. Мы с вами знаем, что в **Python - всё есть объект**, так вот, немного дополним нашу философию объектного мышления и представления:

> Если что-то выглядит как утка, плавает как утка, говорит, как утка, то скорее всего - это утка

Мы будем следовать далее именно такой философии.

(Если говорить серьезно, то определение довольно сложное: ***утиная [типизация](https://ru.wikipedia.org/wiki/Тип_данных)*** ([англ.](https://ru.wikipedia.org/wiki/Английский_язык) *Duck typing*) в [ООП-языках](https://ru.wikipedia.org/wiki/Объектно-ориентированный_язык_программирования) — определение факта реализации определённого [интерфейса](https://ru.wikipedia.org/wiki/Интерфейс_(объектно-ориентированное_программирование)) [объектом](https://ru.wikipedia.org/wiki/Объект_(программирование)) без явного указания или [наследования](https://ru.wikipedia.org/wiki/Наследование_(программирование)) этого интерфейса, а просто по реализации полного набора его [методов](https://ru.wikipedia.org/wiki/Метод_(объектно-ориентированное_программирование)).)

### Сами итераторы

Далее мы посмотрим на такие объекты, которые называются **итераторы**. Скажу заранее, что мы не будем смотреть на внутреннее устройство какого-то итератора или реализовывать свой. Нет, мы просто убедимся в существовании таких объектов.

**Итератор** (iterator) - это объект, который возвращает свои элементы по одному за раз.

С точки зрения утиной типизации - это любой объект, у которого есть методы `__next__` и `__iter__`. 

* `__next__`  - Этот метод возвращает следующий элемент, если он есть, или возвращает исключение StopIteration, когда элементы закончились.

* `__iter__` - С помощью этого метода, итератор запоминает, на каком объекте он остановился в последнюю итерацию. Этот метод просто возвращает сам итератор.

То есть, любой итератор является итерируемым объектом. 

У каждого итерируемого объекта (Iterable object) есть итератор (Iterator), который его итерирует. Получим с помощью функции `iter()`  итератор из Iterable объекта `range`:

```python
r = range(5)
r = iter(r)

print(next(r))
# Выведет: 0
print(next(r))
# Выведет: 1
print(next(r))
# Выведет: 2
```

## Генераторы

Опять же, посмотрим на объект **Генератор** с точки зрения утиной типизации:

Генератор должен обладать методами:

* `__next__` 

* `__iter__`

* `generator.send(arg)`

* `generator.throw(typ[,val[,tb]])`

* `generator.close()`

Вообще говоря, В Python генератор — это объект, который предназначен для создания последовательностей. С его помощью вы можете итерировать потенциально огромные последовательности, не создавая и не сохраняя всю последовательность в памяти сразу. Генераторы часто становятся источником данных для итераторов

Каждый раз, когда вы итерируете через генератор, он отслеживает, где находился во время последнего вызова, и возвращает следующее значение. Это отличает его от обычной функции, которая не помнит о предыдущих вызовах и всегда начинает работу с первой строки в том же состоянии.

Если вы хотите создать потенциально большую (бесконечную) последовательность, вы можете написать функцию-генератор. Это обычная функция, однако она возвращает значение с помощью выражения yield, а не return. Напишем собственную функцию вычисления числа Фибоначчи:

```python
def fib(n):
    x0, x1 = 0, 1
    for _ in range(n):
        yield x0
        x0, x1 = x1, x0 + x1
```

Теперь будем исследовать код, написанный выше:

```python
print(fib(10)) # Выведет: <generator object fib at 0x0000017C46F6AD60>
print(list(fib(10))) # Выведет: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
print(list(fib(100))) # Выведет: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026]
```

Как мы видим, генератор генерирует последовательность **лениво**, то есть грубо говоря, не отдает результат, пока мы явно его не попросим.

Ну и работает такой код **намного** быстрее рекурсии.

**Важно:** Генератор можно запустить лишь однажды. Списки, множества, строки и словари существуют в памяти, а генераторы создают свои значения на лету и выдают их по одному с помощью итератора. Генератор не запоминает значения, поэтому вы не можете перезапустить его или создать резервную копию

## Декораторы

Иногда вам нужно модифицировать существующую функцию, не меняя при этом ее исходный код. Чаще всего добавляется выражение для отладки, чтобы посмотреть, какие аргументы были переданы.

**Декоратор** — это функция, которая принимает одну функцию в качестве аргумента и возвращает другую функцию.

Общий синтаксис декоратора выглядит так:

```python
# Внутри [] - указано что-то опциональное
def Декоратор(func):
    def Обертка(*args, **kwargs):
        [что_мы_делаем_до_вызова_func]
        [res =] func([*args, **kwargs]) # Вызываем func
        [что_мы_делаем_после_вызова_func]
        [return res] # Можем что-то вернуть
    return Обертка
```

Чтобы применить декоратор (то есть передать ему какую-то функцию в качестве аргумента), надо написать:

```python
@Декоратор
def foo():
    тело_функции
```



Ну, например, у меня есть две функции:

```python
def f(a, b):
    return a + b

def g(*args, **kwargs):
    return 'Hello'
```

Я хочу, чтобы при запуске каждой функции, у меня печаталось:

* Имя функции
* Аргументы (позиционные и ключевые)
* Результат

Конечно, я могу вручную написать весь этот код, но, таким образом, я нарушу принцип DRY.

Давайте попробуем, как  - то обобщить этот код, на помощь нам приходят **декораторы**:

```python
def documentation(func): # Написали декоратор
    def wrapper(*args, **kwargs): # Написали обертку
        # Что мы делаем до вызова функции func
        print('[INFO]')
        print(f'Запущена функция {func.__name__}')
        print(f'Позиционные аргументы: {args}')
        print(f'Ключевые аргументы: {kwargs}')
        
        # Выызываем func
        res = func(*args, **kwargs)
        
        # Что мы делаем после вызова функции func
        print(f'Результат: {res}')
        
        # Возвращаем результат
        return res
    return wrapper


@documentation
def f(a, b):
    return a + b

@documentation
def g(*args, **kwargs):
    return 'Hello'

f(5, 3)

g()

# Выведет:
[INFO]
Запущена функция f
Позиционные аргументы: (5, 3)
Ключевые аргументы: {}
Результат: 8
    
[INFO]
Запущена функция g
Позиционные аргументы: ()
Ключевые аргументы: {}
Результат: Hello
```

