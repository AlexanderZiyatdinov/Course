# Словари. Множества. Ветвления.

![image-20210721125400131](http://img1.joyreactor.cc/pics/post/full/it-юмор-geek-doge-Мемы-5952251.png)

## Словари

Мы уже знакомы с таким типом данных, как список (```list```). По сути список представляет из себя некоторую коллекцию элементов, к каждому из которых мы можем обращаться с помощью индексов. Вообще говоря, про любую коллекцию (это может быть ```str```, ```list```, ```tuple``` и др.) мы можем сказать, что такой объект обладает некоторыми отличительными особенностями и свойствами:

* Возможность индексироваться
* Возможность делать срезы
* Получать длину коллекции функцией ```len()```

Примерно так, мы можем себе представлять одномерный список ```a = [1, 13, 2, True, "Hi"]```:

![image-20210721120251130](https://sun9-69.userapi.com/impg/fwpGrNCCufUgd3-ju5iCOo7eVFz1xoD-lgngIg/MlOHxZ41Q9g.jpg?size=1128x592&quality=96&sign=550677b2c85142fbfcd2ed7432c2522c&type=album)

Чтобы обратиться к определенному **элементу** в списке, нам необходимо указать его **индекс**. Теперь рассмотрим схожую коллекцию, правда такую, что в ней обращение к определенному элементу может осуществляться не только по числовому индексу, а совершенно по любому. Эта коллекция или еще говорят структура данных называется **словарь** (```dict```).

``` python
my_dict = dict() # Создание через конструктор объекта
my_dict = {} # Пустой словарь
```

Словарь представляет из себя коллекцию **пар**. Каждая пара - это **ключ**-**значение (key-value).** Рассмотрим подходящий пример:

```python
my_dict = {'cat' : 1, 'dog': "Hi"} # Создали словарь. Ключи: 'cat', 'dog'. Значения: 1, "Hi".
```

**Внимание:** ключ в словаре должен быть уникальным. А вот несколько одинаковых значений быть может.

``` python
my_dict = {'cat' : 1, 'dog': "Hi", "hamster": "Hi"}
print(type(my_dict)) # Выведет: <class 'dict'>
```

Немного забегая вперед, скажем, что словарь - это хэшируемый объект. Это означает, что к объекту применятся специальная хэш-функция. По сути, это функция, которая переводит объект в некоторое числовое представление, благодаря чему поиск в коллекции осуществляется намного быстрее. 

В других языках словарь еще называют ```HashMap```. Саму такую структуру как словарь, можно представлять себе так - это учреждение с огромным количеством кабинетов. Например, в этом учреждении 4 этажа и каждый кабинет представляет из себя трехзначный номер. Где первая цифра - номер этажа, а последние две номер кабинета, причем четные номера находятся с одной стороны а нечетные с другой (короче говоря, как в больнице).

Понятно, что человек не будет искать кабинет номер 404 на первом этаже, и не будет искать его на 4-ом этаже на нечетной стороне. Точно также и при поиске элемента в словаре думает компьютер. Всё это возможно благодаря хэшу.

### Обращение к элементу словаря с помощью [ключ]

Чтобы обратиться к элементу словаря необходимо написать следующее:

```python
my_dict = {'cat' : 1, 'dog': "Hi"}
elem = my_dict['cat']
print(elem) # Выведет: 1
```

Если в словаре такого ключа нет, то выпадет исключение:

``` python
my_dict = {'cat' : 1, 'dog': "Hi"}
elem = my_dict['bird']
print(elem) # Выведет:
# my_dict['bird']
# KeyError: 'bird'
```

### Добавляем или изменяем элемент с помощью [ключ]

Чтобы добавить новую пару **ключ-значение** необходимо сделать следующее:

```python
my_dict = {'cat' : 1, 'dog': "Hi"}
my_dict['bird'] = 'tweet'
print(my_dict['bird']) # Выведет: 'tweet'
```

Как мы видим, никаких дополнительных методов наподобие ```append``` прописывать не нужно.

### Получаем список всех ключей

``` python
my_dict = {'cat' : 'meow', 'dog': "woof", 'bird' : 'tweet'}
keys = my_dict.keys()
print(keys) # Выведет: dict_keys(['cat', 'dog', 'bird'])
```

Обратите внимание, что мы получили спец. объект - ```dict_keys```. 
К сожалению, по нему мы индексироваться не можем, однако можем создать список с помощью конструктора ```list()```.

``` python
my_dict = {'cat' : 'meow', 'dog': "woof", 'bird' : 'tweet'}
keys = my_dict.keys()
print(type(keys)) # Выведет: <class 'dict_keys'>
keys = list(keys)
print(keys) # Выведет: ['cat', 'dog', 'bird']
```

### Получаем список всех значений

Делается это аналогичным образом:

``` python
my_dict = {'cat' : 'meow', 'dog': "woof", 'bird' : 'tweet'}
values = my_dict.values()
print(keys) # Выведет: dict_values(['meow', 'woof', 'tweet'])
```

Всё остальное - так же аналогично.

### Методы работы со словарями

**dict.clear**() - очищает словарь.

**dict.copy**() - возвращает копию словаря.

classmethod **dict.fromkeys**(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

**dict.get**(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

**dict.items**() - возвращает пары (ключ, значение).

**dict.keys**() - возвращает ключи в словаре.

**dict.pop**(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

**dict.popitem**() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.

**dict.setdefault**(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).

**dict.update**([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

**dict.values**() - возвращает значения в словаре.

## Множества

Множество похоже на словарь, в котором значения отброшены, а оставлены только ключи. Как и в словаре, ключи должны быть уникальными. Вы используете множество, если хотите знать только, существует что-то или нет, а другая информация вам неважна. Это как сумка с ключами. Если же вам нужно прикрепить к ключу некую информацию, воспользуйтесь словарем. 

Было время, когда теорию множеств преподавали в некоторых начальных школах наряду с основами математики. Если в вашей школе такого не было (или было, но вы в это время смотрели в окно), на рисунке можно увидеть, как объединяются и пересекаются множества. 

![image-20210721130835451](https://sun9-5.userapi.com/impg/82s1Wq7hmdxf4MJpOzKV8FB88ROuUFwZ0SNz2w/xCLAmBa8ZOk.jpg?size=1169x809&quality=96&sign=dd46d3dd56925413d5d9f1cbed1a3fa9&type=album)

Предположим, вы хотите объединить два множества, у которых есть несколько общих ключей. Поскольку множество должно содержать только уникальные значения, объединение двух множеств будет иметь всего лишь один такой одинаковый ключ. Пустое множество — это множество, содержащее ноль элементов. На рисунке примером пустого множества будут женские имена, начинающиеся с буквы Х.

### Преобразуем другие типы данных с помощью функции set() 

Вы можете создать множество из списка, строки, кортежа или словаря, отбрасывая любые повторяющиеся значения. Для начала взглянем на строку, в которой отдельные буквы встречаются несколько раз: 

```python
>>> set('letters')
{'l', 'r', 's', 't', 'e'}
```

Обратите внимание, что множество содержит только по одной e и t, хотя в слове letters они встречаются дважды. Создадим множество из списка:

``` python
>>> set(['Dasher', 'Dancer', 'Prancer', 'Mason-Dixon'])
{'Dancer', 'Dasher', 'Mason-Dixon', 'Prancer'}
```

А теперь из кортежа:

``` python
>>> set(('Ummagumma', 'Echoes', 'Atom Heart Mother'))
{'Ummagumma', 'Atom Heart Mother', 'Echoes'}
```

Когда вы передаете функции set() словарь, она возвращает только ключи:

``` python
>>> set({'apple': 'red', 'orange': 'orange', 'cherry': 'red'})
{'cherry', 'orange', 'apple'}
```

### Методы работы с множествами:

С множествами можно выполнять множество операций: находить объединение, пересечение...

- len(s) - число элементов в множестве (размер множества).
- x in s - принадлежит ли x множеству s.
- **set.isdisjoint**(other) - истина, если set и other не имеют общих элементов.
- **set == other** - все элементы set принадлежат other, все элементы other принадлежат set.
- **set.issubset**(other) или **set <= other** - все элементы set принадлежат other.
- **set.issuperset**(other) или **set >= other** - аналогично.
- **set.union**(other, ...) или **set | other | ...** - объединение нескольких множеств.
- **set.intersection**(other, ...) или **set & other & ...** - пересечение.
- **set.difference**(other, ...) или **set - other - ...** - множество из всех элементов set, не принадлежащие ни одному из other.
- **set.symmetric_difference**(other); **set ^ other** - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- **set.copy**() - копия множества.

И операции, непосредственно изменяющие множество:

- **set.update**(other, ...); set |= other | ... - объединение.
- **set.intersection_update**(other, ...); set &= other & ... - пересечение.
- **set.difference_update**(other, ...); set -= other | ... - вычитание.
- **set.symmetric_difference_update**(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- **set.add**(elem) - добавляет элемент в множество.
- **set.remove**(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
- **set.discard**(elem) - удаляет элемент, если он находится в множестве.
- **set.pop**() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
- **set.clear**() - очистка множества.

**Пример:**

```python
>>> a = {1, 2}
>>> b = {2, 3}
>>> a & b
{2}
>>> a.intersection(b) # То же самое
{2}
```

**Еще пример:**

```python
>>> a = {1, 2, 3}
>>>a.add(4)
>>>a
{1, 2, 3, 4}
```

Если вы плохо знакомы с множествами или хотите вспомнить кое-что про них, то можете глянуть это [тут](https://ulearn.me/course/math/960e8f63-07c6-4cb7-b103-0a6a67fd0ad8).

## Ветвления. Условные конструкции.

Наверняка, вы видели что-то подобное:

![image-20210721135523243](https://cf.ppt-online.org/files1/slide/7/7P4ZpbI86nSX3VfLK512eYjhDUCqw9gclJ0raxFzO/slide-12.jpg)

Это блок-схема. Табличное представление выполнения кода. Конечно сейчас данная нотация устаревает и на смену им приходят uml-диаграммы, о которых мы поговорим позже, когда будем рассматривать классы (```class```). 

Однако в этой нотации есть одна хорошая деталь: она отражает последовательность выполнения кода. Мы знаем, что код выполняется построчно, начиная с самой верхней строки и так далее. Но что же делать, если нам нужно разделить наш код на две ветки? Для этого существуют условные конструкции в языка программирования (в блок-схемах они отображаются ромбами).

### Конструкция if

Чтобы проверить какое-то условие необходимо написать следующую синтаксическую конструкцию:

```python
if условие:
    тело  # Тело - это некоторый блок команд
```

Заметим, что тело условия снесено на **ЧЕТЫРЕ ПРОБЕЛА (ИЛИ ОДНУ ТАБУЛЯЦИЮ)** вглубь. Такой снос используется в ```Python``` вместо скобок. То есть в другом языке, например ```C#``` мы бы написали:

```c#
if (условие):
{
    тело;
}
```

Тело -  это какой-то набор команд, их может быть одна, две, да хоть сколько. Чтобы показать, что тело пустое, просто напишите там ```...``` или ```pass```.

Вот самый обычный пример:

```python
if 5 > 3:
    print('пять больше трех')
```

Если мы запустим такой код, то у нас напечатается соответствующее сообщение. Это произошло, потому что наше условие выполнилось, либо же можно сказать, что результат выражения равен ```True```.

Рассмотрим другой пример:

```python
if 5 <= 3:
    print('пять меньше либо равно трем')
```

Если мы теперь запустим такой код, то никакого сообщения не увидим, потому что наше условие не выполнилось, т. к. результат выражения ```False```.

### not, or и and

Мы можем управлять синтаксисом внутри наших условий - работать с ними как с выражениями [булевой алгебры](https://ru.wikipedia.org/wiki/Булева_алгебра).

Например мы можем указать на одновременность выполнения нескольких условий, вот так:

```python
a = 10
b = 5
c = 15

if a > b and a < c:
    print('a больше b и a меньше c') # Выведет: a больше b и a меньше c
```

Мы можем записать хоть сколько условий, если **КАЖДОЕ** выполняется (т. е. каждое условие равно ```True```), то и всё выражение равно ```True```. Если **хотя бы одно** не выполняется (т. е. значение хотя бы одного условия равно ```False```), то и всё выражение равно ```False```, и тело блока `if` не выполнится.

Также, мы можем указать на выполнение хотя бы одного условия:

```python
a = 10
b = 5
c = 9
if a > b and a < c:
    print('a больше b или a меньше c') # Выведет: a больше b или a меньше c
```

Мы можем также записать хоть сколько условий, если **ХОТЯ БЫ ОДНО** выполняется (т. е. хотя бы одно условие равно ```True```), то и всё выражение равно ```True```. Если **все условия одновременно** не выполняются (т. е. значения всех условий равно ```False```), то и всё выражение равно ```False```, и тело блока `if` не выполнится.

И еще мы можем наложить отрицание на условие с помощью функции ```not()```:

```python
if not(5 < 3):  # То же самое, что мы бы написали: if 5 >= 3:
    print('пять НЕ меньше трех') # Выведет: пять НЕ меньше трех
```

**Важно 1:** Порядок выполнения операций таков: 

**Важно 2:** Через ```and```, ```or``` и ```not()``` мы можем записать любое условие.

**Важно 3:** Мы можем писать `if` внутри `if`.

### if-else

Окей, предположим, что нам нужно обработать какие-то два противоположных случая. Например, если число, которое ввел пользователь четное, то мы его увеличим на 1 и потом напечатаем, а если число нечетное, то мы его уменьшим на 1 и тоже напечатаем.

Вот так должна работать программа:

```python
# Входные данные:
4
# Выходные данные:
5


# Входные данные:
3
# Выходные данные:
2
```

Ну предположим, мы напишем следующую программу:

```python
num = int(input()) # Вводим число, делаем его int

if num % 2 == 0: # Если число четное (т. е. если остаток от деления на 2 равен 0)
    num += 1   # Прибавляем 1
    print(num) # Печатаем
    
if num % 2 != 0:  # Тут всё аналогично, только число нечетное
    num -= 1
    print(num)

```

Если в такой программе пользователь введет число ```4```, то программа выведет **два числа** ```5``` и ```4```. Это произошло потому, что выполнился первый ```if```, значение переменной ```num``` поменялось и далее выполнился второй ```if```.

Примерно в таких сценариях работы лучше воспользоваться конструкцией ```if-else```

```python
num = int(input()) # Вводим число, делаем его int

if num % 2 == 0: # Если число четное (т. е. если остаток от деления на 2 равен 0)
    num += 1   # Прибавляем 1
    print(num) # Печатаем
else: # Иначе, если число нечетное
    num -= 1
    print(num)
```

Заметим, что команда ```print(num)``` есть и в блоке ```if``` и в блоке ```else```, кажется, что мы можем её вынести и избавиться от копирования кода:

``` python
num = int(input()) # Вводим число, делаем его int

if num % 2 == 0: # Если число четное (т. е. если остаток от деления на 2 равен 0)
    num += 1   # Прибавляем 1
else: # Иначе, если число нечетное
    num -= 1
print(num)
```

**Внимание:** ```else``` относится всегда к последнему ```if```.

### if-elif-else

Если нам надо проверить более чем два условия, то теперь мы можем воспользоваться следующим синтаксисом:

```python
# Хотим проверить равно ли введеное значение 1, 2, 3 или 4. Или вообще ничему из этого оно не равно.
# Взависимости от этого надо напечатать определенное сообщение
# Мы можем написать четыре if, но как мы поняли мы это невсегда правильно

a = int(input())

if a == 1:
    print('One')
else if a == 2: # Иначе, если a равно 2
    print('Two')
else if a == 3: # Иначе, если a равно 3
    print('Three')
else if a == 4: # Иначе, если a равно 4
    print('Four')
else: # Иначе, если вообще ничего не выполнилось
    print('Nothing')
```

Но в ```Python``` существует специальное ключевое слово, которое называется ```elif``` - сокращение от ```else-if```. Значит мы можем переписать код сверху вот так:

```python
# Хотим проверить равно ли введеное значение 1, 2, 3 или 4. Или вообще ничему из этого оно не равно.
# Взависимости от этого надо напечатать определенное сообщение
# Мы можем написать четыре if, но как мы поняли мы это невсегда правильно

a = int(input())

if a == 1:
    print('One')
elif a == 2: # Иначе, если a равно 2
    print('Two')
elif a == 3: # Иначе, если a равно 3
    print('Three')
elif a == 4: # Иначе, если a равно 4
    print('Four')
else: # Иначе, если вообще ничего не выполнилось
    print('Nothing')
```

**Внимание:** Обычно, когда нужно проверить много условий, то пишу конструкцию такого вида:

```python
if условие:
    тело
elif условие:
    тело
elif условие:
    тело
    
... и т. д.

elif условие:
    тело
else:
    тело
```

### Truthy и Falsy значения

На самом деле, когда мы пишем какое-то условие после `if` или `elif`, то к этому условию применяется конструктор ```bool()```.

В ```Python``` существуют некоторые правила, согласно которым у каждого значения есть предопределённость будет ли он `True` или `False` после `bool()`.
Такие правила называются **Truthy** и **Falsy**. Про каждое конкретное значение мы можем сказать оно является **Truthy**  или оно является **Falsy**.

На русский это переводится примерно так: "истинноватые" и "ложневатые". Общепринятого русского перевода нет.

Вот как это работает:

```python
>>> a = 5
>>> if a:
    print(a) # Выведется 5
    
>>> a = 0
>>> if a:
    print(a) # Ничего не выводится
```

Так произошло, потому что в первом случае `a=5` к нему применилась функция `bool()` результат `bool(5)=True`, поэтому условие выполнилось. Во втором случае `a=0` к нему применилась функция `bool()` результат `bool(0)=False`, поэтому условие не выполнилось.

Вот список большинства значений, которые равны ```False``` после применения ```bool```:

#### Falsy Значения

**Коллекции**:

- Пустой список `[]`
- Пустой кортеж `()`
- Пустой словарь `{}`
- Пустое множество `set()`
- Пустая строка `""`
- Пустой range `range(0)`

**Числовые типы**

- Ноль любого числового типа.
- Int: `0`
- Float: `0.0`
- Complex: `0j`

**Константы**

- `None`
- `False`

Как мы видим, все что имеет либо пустоту, либо 0, либо ничего (`None`) и т.д. - является `Falsy` значением.

Значит вот так мы можем проверить является ли список пустым или нет:

```python
a = []

if a:
    print('Список не пустой') # Ничего не выведется
    
a.append(1)

if a:
    print('Список не пустой') # Выведется: Список не пустой
```

Всё остальное является `Truthy` значениями.

### Операторы == и !=

Чтобы проверить, что два объекта равны (не равны) **по значению** используйте оператор `==` (`!=`)

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b) # Выведет: True
```

### Оператор is

Чтобы проверить, что два объекта равны (не равны) **по ссылке** используйте оператор `is`

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b) # Выведет: False
```

### Оператор in

Чтобы проверить, что определённый элемент есть в коллекции (т. е. например в строке, в списке, в словаре и т. д.) используйте оператор `in`

```python
a = [1, 2, 3]

print(2 in a) # Выведет: True

print(4 in a) # Выведет: False
```



