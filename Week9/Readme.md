# Классы. Свойства (геттеры и сеттеры).

![img](https://habrastorage.org/webt/9s/gq/ch/9sgqchcuzrso9iesrjn7vkw9opw.png)

И вот этот день настал, мы вплотную подобрались к созданию собственных типов объектов, по-другому - **классов**.

Еще раз напомним, что в Python, как и во многих других объектно-ориентированных языках выполнимо правило: **Всё - есть объект**. Давайте же немного поговорим про то, что вообще из себя представляет объектно-ориентированное программирование (ООП) .

## Немного про ООП

(*Данные с сайта: https://skillbox.ru/media/code/oop_chast_1_chto_takoe_klassy_i_obekty/*)

**Объектно-ориентированное программирование** *(сокращенно ООП)* — это парадигма разработки программных систем, в которой приложения состоят из объектов.

**Объекты** — это сущности, у которых есть свойства и поведение. Обычно объекты являются экземплярами какого-нибудь класса. Например, в игре может быть класс *Character* *(персонаж)*, а его экземплярами будут *hero* или *npc*.

**Атрибуты** — это данные, которые связаны с конкретным объектом:

- здоровье;
- очки;
- деньги;
- сила;
- ловкость;
- интеллект;
- скорость;
- координаты.

Поведение объекта определяется с помощью **методов** — специальных блоков кода, которые можно вызывать из разных частей программы. Например, у того же объекта *Character* могут быть следующие методы:

- идти;
- атаковать;
- говорить;
- подобрать;
- выбросить;
- использовать.

Используя эти свойства и методы, можно значительно ускорить разработку, сделать код более читаемым. К тому же самому программисту проще составлять код, если он думает с помощью объектов.

То есть он не пишет какую-то функцию, которая будет делать что-то для программы в целом. Вместо этого он мысленно разделяет приложение на отдельные компоненты и продумывает их свойства и поведение.

Такую парадигму используют многие популярные языки:

- C#;
- Java;
- Python;
- JavaScript;
- PHP;
- Kotlin;
- Swift;
- Objective-C;
- C++.

#### **Плюсы и минусы объектно-ориентированного программирования**

|                          **Плюсы**                           |                            Минусы                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| *Легко читается.* Не нужно выискивать в коде функции и выяснять, за что они отвечают. | *Потребляет больше памяти.* Объекты потребляют больше оперативной памяти, чем примитивные типы данных. |
| *Быстро пишется.* Можно быстро создать сущности, с которыми должна работать программа. | ***Снижает производительность.\*** Многие вещи технически реализованы иначе, поэтому они используют больше ресурсов. |
| *Проще реализовать большой функционал.* Так как на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей. | *Сложно начать.* Парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени. |
| *Меньше повторений.* Не нужно писать однотипные функции для разных сущностей |                                                              |

## Классы в Python

Теперь давайте попробуем создать собственный класс, который описывает довольно простой объект - окружность. Все мы проходили в школе окружность, и знаем, что она задается следующим уравнением:

![image-20210815154432087](https://sun9-64.userapi.com/impg/qQyqYHeJdjzjXGUR6zzC8AZfqAPo9Ox-jgb-JQ/Fna2_b1DzBY.jpg?size=165x51&quality=96&sign=80a86669ccefaf831bb54e8f2cc9e14f&type=album)

Если описать данное уравнение словами, то можно сказать, что окружность - это геометрическое место точек вида `(x,y)`, равноудалённых от центра окружности `(0,0)` на расстояние `r`.

Теперь необходимо понять, а как мы представим нашу окружность в коде?

### Tuple

Попробуем представить в виде кортежа (`tuple`)

```python
circle = 1, 2, 3
```

Недостатки такого подхода:

*  Нельзя изменить объект
* Непонятно, что именно олицетворяет каждое значение
* Индексация
* Нельзя проверить корректность
* Невозможность написать какие-нибудь методы (Например, вычисление площади)

### List

Быть может нам подойдет список (`list`) ?

```python
circle = [1, 2, 3]
```

Тут мы тоже сталкиваемся с рядом проблем:

* Непонятно, что именно олицетворяет каждое значение
* Нельзя проверить корректность
* Невозможность написать какие-нибудь методы (Например, вычисление площади)
* Индексация
* Легко "испортить" объект

### Dict

Окей, быть может со всей этой неразберихой нам поможет словарь (`dict`) ?

```python
circle = {
    'x': 1,
    'y': 2,
    'r': 3,
}
```

Но и тут нас поджидают некоторые проблемы:

* Нельзя проверить корректность
* Невозможность написать какие-нибудь методы (Например, вычисление площади)
* Легко "испортить" объект

### Class

На самом деле для того, чтобы описать какой-либо объект различной природы, необходимо пользоваться конструкцией `class`:

```python
class Circle: # Описали класс Circle
    x = 1
    y = 2
    r = 3
    
c = Circle() # Создали экземляр класса Circle
print(c.x) # Выведет: 1
print(c.y) # Выведет: 2
print(c.r) # Выведет: 3

```

Окей, теперь всё стало более очевидно, но что, если мы хотим создать несколько окружностей, с разными атрибутами.

**Важно:** 

* **Атрибут** — это переменная, расположенная внутри класса или объекта. Во время и после создания объекта или класса вы можете присвоить им атрибуты. Атрибутом может быть любой другой объект.
* **Метод** — это функция класса или объекта. Метод выглядит так же, как и любая другая функция, но может быть использован особым образом.

Тогда нам следует присваивать атрибуты нашему объекту во время создания, для этого нам потребуется специальный метод `__init__`:

```python
class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
```

Так выглядят реальные определения классов в Python. Согласен, __init__() и **self** смотрятся странно. 

* __init__() — это особое имя метода, который инициализирует отдельный объект с помощью определения его класса . 
* Аргумент **self** указывает на сам объект. 

Когда вы указываете __init__() в определении класса, его первым параметром должен быть объект с именем self. Несмотря на то что в Python self не является зарезервированным словом, оно применяется довольно часто. Никому из тех, кто будет читать ваш код позже (включая вас!), не придется гадать, что вы имели в виду, когда использовали слово self.

Пример работоспособности:

```python
class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
        
circle1 = Circle(1, 2, 3)
circle2 = Circle(3, 4, 5)

print(circle1.x) # Вывведет: 1
print(circle2.x) # Вывведет: 3
```

Как мы видим создались два различных экземпляра класса `Circle`, каждый из которых проинициализирован своим набором значений.

## Пишем собственный метод

Давайте теперь допишем к нашему коду несколько строк, чтобы добавить метод в наш класс. Пусть этот метод будет считать площадь круга, ограниченного окружностью.

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
    
    def area(self):
        return math.pi * self.r ** 2
```

Обратите внимание, что мы получаем доступ к атрибуту `r` через конструкцию `self.r`, то есть для каждого отдельно экземпляра объекта вместо `self.r` будет подставлено своё значение атрибута `r`.

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
    
    def area(self):
        return math.pi * self.r ** 2
    
circle = Circle(1, 2, 3)
print(circle.area())  # Выведет: 28.274333882308138
```

**Важно:** Методы внутри классов бывают **статические (static)** и **динамические (dynamic)**

* Условно говоря, **динамические** методы - это самые обычные методы, которые непосредственно взаимодействуют с экземпляром класса
* **Статические** методы не требуют экземпляра класса, их обычно помечают декоратором `@staticmethod`

## Модификаторы доступа. Инкапсуляция.

В парадигме ООП вы часто можете слышать три заветных слова: **Инкапсуляция**, **Наследование** и **Полиморфизм**.

Сегодня мы поговорим только про первый из них. Про остальные более детально и обстоятельно поговорим в следующий раз.

### Инкапсуляция.

**Инкапсуляция** - это:

* механизм, позволяющий изолировать отдельные программные сущности друг от друга
* механизм, позволяющий сгруппировать несколько взаимосвязанных элементов программы в одну новую программную сущность.

Отличным примером инкапсуляции послужит микроволновая печь, ведь в ней вся основная "логика" (вернее механизмы работы устройства) закрыта для обычного потребителя. Все провода, все рабочие элементы - всё изолировано. Главная цель такой изоляции - оградить пользователя от опасных и неосторожных действий. Подразумевается, что разбираться во всех тонкостях и деталях устройства микроволновой печи должен специально обученный человек.

Инкапсуляция может действовать на следующих уровнях при проектировании кода:

* Инкапсуляция только логики - в функциях
* Инкапсуляция модели данных и модели поведения - в классах
* Инкапсуляция логики - в модуле/библиотеке
* Инкапсуляция логики и доп. ограничение на взаимодействие - в приложении

Мы будем рассматривать инкапсуляцию на уровне класса. Она позволяет:

* **Группировать** схожие по смыслу участки кода в логически значимые единицы (т. е. в объекты, классы)
* Обеспечивает **контролируемый** доступ к атрибутам и методам.
* Пресекает спонтанный доступ извне к содержимому класса
* Обеспечивает **ожидаемое** поведение при изменении программы
* Гарантирует **целостность** и **корректность** данных

### Модификаторы доступа

Во многих (особенно C-подобных) языках программирования существуют так называемые модификаторы доступа. Это специальные ключевые слова, которые сообщают: можно ли использовать конкретный атрибут или метод или доступ к нему ограничен. В Python как таковых модификаторов доступа **НЕТ**, но есть схожие механизмы, позволяющие применить некоторые задачи инкапсуляции на практике.

Например, я хочу запретить использовать атрибут `r` нашего класса `Circle`. Для этого я должен поставить `__` перед именем соответствующего атрибута или метода. В таком случае, мы не сможем обращаться к данному атрибуту вне класса (внутри класса сможем).

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.__r = r
    
    def area(self):
        return math.pi * self.r ** 2
    
circle = Circle(3, 4, 5)
print(circle.r)

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-1-3c45ab191cd1> in <module>
     11 
     12 circle = Circle(3, 4, 5)
---> 13 print(circle.r)

AttributeError: 'Circle' object has no attribute 'r'
```

**Важно:** На самом деле, если ухитриться, то получить доступ к этому атрибуту можно.

Как мы можем заметить, теперь мы не можем сделать вот такую пакость: `circle.r = 10`, т. к. просто не сможем обратиться к данному атрибуту. Однако возникает другой вопрос: что делать, если мне необходимо убрать доступ к непосредственному обращению/изменению атрибута (или метода), но как-то надо получать значение. Для этого существуют свойства - **Геттеры и Сеттеры** (Getters and Setters)

### Геттеры и Сеттеры

Отдельные объектно-ориентированные языки поддерживают закрытые атрибуты объектов, к которым нельзя получить доступ напрямую. Программистам часто приходится писать **геттеры** и **сеттеры**, чтобы прочитать и записать значения таких атрибутов. В Python нет закрытых атрибутов, но вы можете написать геттеры и сеттеры для атрибутов с обфусцированными именами, чтобы создать нечто подобное, а вообще говоря, лучшим решением будет использование свойств.

По сути, геттер и сеттер - это специальные методы, которые позволяют читать/изменять обфусцированные имена, т. е. имена с `__` в начале.

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.__r = r
    # Мы до сих пор можем напрямую обращаться к атрибуту внутри класса!
    # Но не можем обращаться к нему снаружи.
    def get_r(self): # Геттер - метод для получения обфусцированного значения
        return self.__r 
    
    def set_r(self, r): # Сеттер - метод для изменения обфусцированного значения
        self.__r = r
    
    def area(self):
        return math.pi * self.r ** 2
    
circle = Circle(3, 4, 5)

print(circle.get_r())
circle.set_r(10)
print(circle.get_r())

# Выведет:
5
10
```

Не всегда удобно писать и обращаться к геттера и сеттера как к методам, т. е. так `object.method(arg)` , вот если бы мы могли изменять или читать значение так же, как и при работе с обычным атрибутом...

### Свойства

Более Pythonic way решением для закрытия атрибутов является использование **свойств** - специальных конструкций, представляющих из себя декораторы, позволяющее обращаться к закрытому полю так, как будто мы обращаемся к атрибуту.

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.__r = r

    @property
    def r(self): # Геттер - метод для получения обфусцированного значения
        return self.__r 
    
    @r.setter
    def r(self, r): # Сеттер - метод для изменения обфусцированного значения
        self.__r = r
    
    def area(self):
        return math.pi * self.r ** 2
    
circle = Circle(3, 4, 5)

print(circle.r)
circle.r = 10
print(circle.r)

# Выведет:
5
10
```

Мы заменили методы `get_r()` и `set_r()` на соответствующие свойства `@property` и `@r.setter`.

