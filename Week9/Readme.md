# Классы. Свойства (геттеры и сеттеры).

![img](https://habrastorage.org/webt/9s/gq/ch/9sgqchcuzrso9iesrjn7vkw9opw.png)

И вот этот день настал, мы вплотную подобрались к созданию собственных типов объектов, по-другому - **классов**.

Еще раз напомним, что в Python, как и во многих других объектно-ориентированных языках выполнимо правило: **Всё - есть объект**. Давайте же немного поговорим про то, что вообще из себя представляет объектно-ориентированное программирование (ООП) .

## Немного про ООП

(*Данные с сайта: https://skillbox.ru/media/code/oop_chast_1_chto_takoe_klassy_i_obekty/*)

**Объектно-ориентированное программирование** *(сокращенно ООП)* — это парадигма разработки программных систем, в которой приложения состоят из объектов.

**Объекты** — это сущности, у которых есть свойства и поведение. Обычно объекты являются экземплярами какого-нибудь класса. Например, в игре может быть класс *Character* *(персонаж)*, а его экземплярами будут *hero* или *npc*.

**Атрибуты** — это данные, которые связаны с конкретным объектом:

- здоровье;
- очки;
- деньги;
- сила;
- ловкость;
- интеллект;
- скорость;
- координаты.

Поведение объекта определяется с помощью **методов** — специальных блоков кода, которые можно вызывать из разных частей программы. Например, у того же объекта *Character* могут быть следующие методы:

- идти;
- атаковать;
- говорить;
- подобрать;
- выбросить;
- использовать.

Используя эти свойства и методы, можно значительно ускорить разработку, сделать код более читаемым. К тому же самому программисту проще составлять код, если он думает с помощью объектов.

То есть он не пишет какую-то функцию, которая будет делать что-то для программы в целом. Вместо этого он мысленно разделяет приложение на отдельные компоненты и продумывает их свойства и поведение.

Такую парадигму используют многие популярные языки:

- C#;
- Java;
- Python;
- JavaScript;
- PHP;
- Kotlin;
- Swift;
- Objective-C;
- C++.

#### **Плюсы и минусы объектно-ориентированного программирования**

|                          **Плюсы**                           |                            Минусы                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| *Легко читается.* Не нужно выискивать в коде функции и выяснять, за что они отвечают. | *Потребляет больше памяти.* Объекты потребляют больше оперативной памяти, чем примитивные типы данных. |
| *Быстро пишется.* Можно быстро создать сущности, с которыми должна работать программа. | ***Снижает производительность.\*** Многие вещи технически реализованы иначе, поэтому они используют больше ресурсов. |
| *Проще реализовать большой функционал.* Так как на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей. | *Сложно начать.* Парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени. |
| *Меньше повторений.* Не нужно писать однотипные функции для разных сущностей |                                                              |

## Классы в Python

Теперь давайте попробуем создать собственный класс, который описывает довольно простой объект - окружность. Все мы проходили в школе окружность, и знаем, что она задается следующим уравнением:

![image-20210815154432087](https://sun9-64.userapi.com/impg/qQyqYHeJdjzjXGUR6zzC8AZfqAPo9Ox-jgb-JQ/Fna2_b1DzBY.jpg?size=165x51&quality=96&sign=80a86669ccefaf831bb54e8f2cc9e14f&type=album)

Если описать данное уравнение словами, то можно сказать, что окружность - это геометрическое место точек вида `(x,y)`, равноудалённых от центра окружности `(0,0)` на расстояние `r`.

Теперь необходимо понять, а как мы представим нашу окружность в коде?

### Tuple

Попробуем представить в виде кортежа (`tuple`)

```python
circle = 1, 2, 3
```

Недостатки такого подхода:

*  Нельзя изменить объект
* Непонятно, что именно олицетворяет каждое значение
* Индексация
* Нельзя проверить корректность
* Невозможность написать какие-нибудь методы (Например, вычисление площади)

### List

Быть может нам подойдет список (`list`) ?

```python
circle = [1, 2, 3]
```

Тут мы тоже сталкиваемся с рядом проблем:

* Непонятно, что именно олицетворяет каждое значение
* Нельзя проверить корректность
* Невозможность написать какие-нибудь методы (Например, вычисление площади)
* Индексация
* Легко "испортить" объект

### Dict

Окей, быть может со всей этой неразберихой нам поможет словарь (`dict`) ?

```python
circle = {
    'x': 1,
    'y': 2,
    'r': 3,
}
```

Но и тут нас поджидают некоторые проблемы:

* Нельзя проверить корректность
* Невозможность написать какие-нибудь методы (Например, вычисление площади)
* Легко "испортить" объект

### Class

На самом деле для того, чтобы описать какой-либо объект различной природы, необходимо пользоваться конструкцией `class`:

```python
class Circle: # Описали класс Circle
    x = 1
    y = 2
    r = 3
    
c = Circle() # Создали экземляр класса Circle
print(c.x) # Выведет: 1
print(c.y) # Выведет: 2
print(c.r) # Выведет: 3

```

Окей, теперь всё стало более очевидно, но что, если мы хотим создать несколько окружностей, с разными атрибутами.

**Важно:** 

* **Атрибут** — это переменная, расположенная внутри класса или объекта. Во время и после создания объекта или класса вы можете присвоить им атрибуты. Атрибутом может быть любой другой объект.
* **Метод** — это функция класса или объекта. Метод выглядит так же, как и любая другая функция, но может быть использован особым образом.

Тогда нам следует присваивать атрибуты нашему объекту во время создания, для этого нам потребуется специальный метод `__init__`:

```python
class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
```

Так выглядят реальные определения классов в Python. Согласен, __init__() и **self** смотрятся странно. 

* __init__() — это особое имя метода, который инициализирует отдельный объект с помощью определения его класса . 
* Аргумент **self** указывает на сам объект. 

Когда вы указываете __init__() в определении класса, его первым параметром должен быть объект с именем self. Несмотря на то что в Python self не является зарезервированным словом, оно применяется довольно часто. Никому из тех, кто будет читать ваш код позже (включая вас!), не придется гадать, что вы имели в виду, когда использовали слово self.

Пример работоспособности:

```python
class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
        
circle1 = Circle(1, 2, 3)
circle2 = Circle(3, 4, 5)

print(circle1.x) # Вывведет: 1
print(circle2.x) # Вывведет: 3
```

Как мы видим создались два различных экземпляра класса `Circle`, каждый из которых проинициализирован своим набором значений.

## Пишем собственный метод

Давайте теперь допишем к нашему коду несколько строк, чтобы добавить метод в наш класс. Пусть этот метод будет считать площадь круга, ограниченного окружностью.

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
    
    def area(self):
        return math.pi * self.r ** 2
```

Обратите внимание, что мы получаем доступ к атрибуту `r` через конструкцию `self.r`, то есть для каждого отдельно экземпляра объекта вместо `self.r` будет подставлено своё значение атрибута `r`.

```python
import math

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
    
    def area(self):
        return math.pi * self.r ** 2
    
circle = Circle(1, 2, 3)
print(circle.area())  # Выведет: 28.274333882308138
```

