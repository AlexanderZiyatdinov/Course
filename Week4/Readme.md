# Циклы for, while. comprehensions

![img](https://64.media.tumblr.com/2e9b406dafaa5a23be7396c40e8c835a/tumblr_n2msdxQg1X1s58xkdo1_r1_1280.gif)

Окей, мы с вами уже знаем условные конструкции ```if-elif-else```. Проверки с использованием этой конструкции выполняются шаг за шагом, последовательно. Но что, если нам необходимо сделать несколько однотипным операций?  Мы, конечно, можем написать столько инструкций (или блоков инструкций) сколько нам надо, однако тем самым мы нарушим один из основы принципов программирования - **DRY**

## Принцип программирования DRY

*Don’t Repeat Yourself / Не повторяй сам себя*

**Эта концепция говорит:** если ты что-то сделал, то не повторяй этого снова. 

Если вы видите, что написанный вами участок кода напоминает какой-то из предыдущих, то видимо, вы что-то делаете не так. Попробуйте вынести ваш код в какую-нибудь языковую конструкцию (цикл, функция и т. п.).

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

## Цикл While

Самым простым способом выполнить какой-то код несколько раз является `while`. Рассмотрим код, который выводит на экран числа от 1 до 10:

```python
count = 1
while count <= 10:
    print(count)
    count += 1
```

Сначала мы создали переменную `count` и проинициализировали её значением `1`. После этого у нас произошло сравнение `count` и `10`, данное выражение вернуло результат `True` (т. к. `bool(1 <= 10)` - это `True`), следовательно мы зашли в **тело цикла**. Напечатали значение переменной `count` (т. е. `1` ) и инкрементировали её значение. Далее у нас бы происходила аналогичная проверка для нового значения переменной `count` - `2` и т .д. вплоть до `10`. Если `count` равна `10`, то результат условия вернет `False`, следовательно мы не зайдем в **тело цикла **и пойдем выполнять строки программы, которые идут следом за блоком `while`.

Как можно заметить, синтаксис конструкции выглядит следующим образом:

```python
while условие:
    тело_цикла
```

На русский язык можно перевести так: *ПОКА выполняется УСЛОВИЕ, то делай ТЕЛО_ЦИКЛА*

Нетрудно понять, что мы можем создать **вечный цикл**:

```python
while True:
    тело_цикла
```

Такой цикл будет выполняться постоянно.

### Прерывание цикла. Команда break.

Если нам хочется остановить выполнение цикла, мы можем воспользоваться командой `break`, делается это так:

Предположим, что мы считываем целые положительные числа с клавиатуры, мы хотим печатать только нечетные. Если же нам пришло четное число, мы должны остановить выполнение цикла и написать какое-нибудь сообщение.

```python
while True:
    number = int(input()) # Считали число
    if number % 2 == 0: # Если оно четное
        print('Считанное число четное') # Выводим сообщение
        break # Выходим из цикла
    print(number) # В противном случае (если мы не попали в блок if) печатаем значение числа
```

### Пропуск итерации цикла. Команда continue.

Начнем с небольшого, но важного определения:

**Итерация** (лат. iteratio «повторение») — повторение какого-либо действия. В программировании под итерацией понимают - один "проход" цикла. Кстати в Python существуют **Итерируемые объекты (Iterable objects)**  т. е. такие объекты, которые предоставляют возможность поочередного прохода по своим элементам.

Иногда в некоторых сценариях работы нам требуется не остановить выполнения цикла, а перейти на следующую итерацию. Ну, например, рассмотрим предыдущий сценарий работы, только сейчас, если попалось четное число, мы просто перейдем на следующий шаг.

```python
while True:
    number = int(input()) # Считали число
    if number % 2 == 0: # Если оно четное
        continue # Переходим на следующий шаг цикла
    print(number) # В противном случае (если мы не попали в блок if) печатаем значение числа
```

### Проверка завершения цикла. Блок else.

Если цикл while завершился без вызова break, то управление передается в опциональный блок else. Мы можем воспользоваться этим, когда кодируем цикл так, чтобы, выполняя некоторую проверку, он прервался, как только проверка успешно выполнится.

```python
count = 1
while count <= 10:
    number = int(input())
    if number % 2 == 0:
        print('Считано четное число')
        break
else:
    print('Все десять чисел были нечетными')
```

Теперь поправим итоговый синтаксис блока `while`. Внутри `[ ]` я обычно помещаю что-то опциональное :)

```python
while условие:
    тело_цикла
[else]:
    тело_блока
```

## Цикл for

Цикл `for` представляет из себя некоторый `синтаксический сахар` цикла `while`. Его синтаксис немного проще, но по сути он выполняет всё то же самое:

```python
for переменная in коллекция:
    тело_цикла
```

Под словом `коллекция` понимается некоторый объект, по которому мы можем итерироваться. По сути это [`Iterable`](https://pyneng.readthedocs.io/ru/latest/book/13_iterator_generator/iterable.html) объект. Ну это и понятно, поскольку мы знаем, что оператор `in` мы можем применить для проверки того, содержится ли объект `a` в `Iterable` объекте `b`:

```python
a in b # ???
```

Давайте более подробно рассмотрим работу цикла `for`.

### Проход по Iterable object

Рассмотрим такой пример: необходимо вывести каждое предложение некоторого текста с новой строки. За основу возьмем такой [текст](https://ru.wikipedia.org/wiki/Lorem_ipsum):

```python
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
```

Напишем небольшую программу:

```python
text = """Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.""" # Сохранили весь наш текст в переменную

sentences = text.split('. ') # С помощью метода <str>.split() мы разбили текст по строке ". " (точка и пробел). 
# В итоге переменная sentences - это список предложений исходного текста, т. е. sentences[0] - это первое предложение, sentences[2] - второе и т. д.

for sentence in sentences: # Говорим, что переменная sentence будет проходиться по sentences и принимать очередное значение
    print(sentence)
    
# Вывод:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur
Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

```

Как мы видим цикл `for` прошелся по каждому предложению в списке наших предложений.

Другой пример, более приземленный:

```python
for elem in [1, 2, 3, 4]:
    print(elem, end=' ')
# Вывод:
1 2 3 4 
```

### Проход по индексам Iterable object

Иногда нам приходится изменять содержимое какой-то коллекции. Например, я хочу увеличить вдвое каждый элемент моего списка:

```python
a = [1, 2, 3, 4]
for elem in a:
    elem *= 2
print(a)

# Вывод: 
[1, 2, 3, 4]
```

Ничего не изменилось :( Дело в том, что переменная `elem` - это лишь некоторая временная переменная, которая принимает значение равное очередному элементу коллекции, при этом `elem` никак не ссылается на реальное содержимое коллекции.

Тогда, мы можем написать что-то подобное:

```python
a = [1, 2, 3, 4]
for i in (1, 2, 3, 4):    
    a[i] *= 2
print(a)
# Вывод: 
[2, 4, 6, 8]
```

Дело лучше, но... что если нам нужно будет поменять 100 элементов, 1000 или 1000000, не будем же мы писать `tuple` все время. Для решения такой проблемы у нас есть специальная функция `range()`, которая генерирует специальный объект  `<class 'range'>` - по сути числовую коллекцию.

*Примечание: обычно при перечислении индексов пишут буквы i, j, k и так далее. Ибо данные обозначения лишь символизируют индекс коллекции и не несут какого-то семантического смысла. А если нам неважен и индекс, то обычно пишут символ:  _*

```python
for i in range(10):
    print(i, end=' ')
# Вывод:
0 1 2 3 4 5 6 7 8 9
```

Функция принимает три аргумента: `range([start], stop, [step])` - первые два являются необязательными.

* [start] -  начало коллекции. По умолчанию равно 0
* stop - конец коллекции, не включается в саму коллекцию. (см. пример выше)
* [step] - шаг, по сути то же самое, что и в `slices` у `iterable objects`

Чтобы более детально изучить поведение функции - поэкспериментируйте с ней в `Python` самостоятельно. 

Теперь перепишем наш пример, немного по-другому:

```python
a = [1, 2, 3, 4]
for i in range(4):
    a[i] *= 2
print(a)
# Вывод: 
[2, 4, 6, 8]
```

А можно даже так:

```python
a = [1, 2, 3, 4]
for i in range(len(a)):
    a[i] *= 2
print(a)
# Вывод: 
[2, 4, 6, 8]
```

### break и continue. else.

И `break`, и `continue`, `else` работают в цикле `for` так же, как и в `while`

### Сходство While и For

Как упоминалось ранее: `for` - это синтаксический сахар для `while`. Иногда бывает очень полезно уметь переписать один цикл в другой. Например вот так:

```python
# While
count = 0
while count < 10:
    print(count)
    count += 1
    
# for
for count in range(10):
    print(count)
```

### Заполнение коллекций с помощью for

С помощью цикла нам удобно создавать большие коллекции. Например, я хочу создать список из 10000 случайных целых чисел от 1 до 100:

```python
import random # Импортируем библиотеку, которая отвечает за рандомные значения

a = [] # Объявляем наш список
for _ in range(10000): # Повторить 10000 раз
    a.append(random.randint(1, 100)) # Добавляем в список a очередное случайное целое число от 1 до 100
```

### While vs. For

Так когда же лучше использовать `while `, а когда `for` ?

for и while теоретически взаимозаменяемы, однако нужно понимать, когда стоит использовать каждый из них. Вот рекомендации по выбору между `for `и `while`:

- Заранее известно сколько раз нужно повторить действие — используйте **for**.
- Есть переменная, изменяемая каждую итерацию и у нее есть понятный смысл — используйте **for**.
- Иначе — используйте **while**.

## Comprehensions

Вернемся к созданию списков.

Списки можно создавать не только с помощью `for`, для этой задачи существует специальный синтаксис, генерирующий списки. Называется он **List Comprehenstions**

```python
a = [0 for i in range(10)]
print(a)

# Выведет:
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Можно пойти чуть дальше:

```python
a = [i for i in range(10)]
print(a)

# Выведет:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

И еще дальше:

```python
a = [i for i in range(10) if i % 2 == 0]
print(a)

# Выведет:
[0, 2, 4, 6, 8]
```

Общий синтаксис конструкции выглядит так:

```python
[элемент for переменная in коллекция [if условие]] # if условие - опциональный параметр
```