# Коллекции. Кортежи, Списки.

![img](https://dijeans.ru/upload/resize_cache/iblock/4ce/440_250_1/4cefcc5183ed1a760805ce2aed1a08a7.jpg)

В предыдущий раз мы говорили о базовых типах данных Python, таких как булевы значения, целочисленные значения, числа с плавающей точкой и строки. Если представлять их как атомы, то структуры данных, которые мы рассмотрим в этой главе, можно назвать молекулами. Так и есть: мы объединим базовые типы в более сложные структуры, которые вы будете использовать каждый день. БОльшая часть работы программиста состоит из «разрезания» данных и «склеивания» их в конкретные формы, поэтому сейчас вы узнаете, как всё происходит.

## Немного про строки

![img](https://i.ytimg.com/vi/nYFd7VHKyWQ/maxresdefault.jpg)

Строки являются первым примером последовательностей в Python. В частности, они представляют собой последовательности символов. Но что такое символ? Это наименьшая единица письменной системы, которая может быть буквой, цифрой, специальным символом, знаком препинания и даже пробелом. 

В отличие от других языков в Python строки являются неизменяемыми. Вы не можете изменить саму строку, но можете скопировать части строк в другую строку, чтобы добиться подобного эффекта. Скоро вы узнаете, как это делается.

Вы уже знаете, что создать строку из любого другого типа данных можно с помощью функции ```str()```

``` python
>>>str(42)
'42'
>>>str(True)
'True'
```

### escape-последовательности

Python позволяет использовать escape-последовательности внутри строк, чтобы добиться эффекта, который по-другому выразить было бы трудно. Символ с размещенным перед ним обратным слешем (\) получает особое значение. Наиболее распространена последовательность **\n**, которая **означает переход на новую строку**. С ее помощью можно создавать многострочные строки из однострочных:

```python
>>>string = 'Hello!\nMy name is John'
>>>print(string)
Hello
My name is John
```

Последовательность **\t** (табуляция) используется для выравнивания текста:

```python
>>> print('\tabc')
 abc
```

Кроме того, вам могут понадобиться последовательности \' или \", чтобы поместить одинарные или двойные кавычки в строку, заключенную в такие же символы:

```python
>>>print('\'\"')
'"
```

А если вам нужен обратный слеш, просто напечатайте два (первый из них экранирует второй):

```python
>>>print('\\')
\
```

### Объединяем (конкатенируем) строки с использованием символа +

В Python вы можете объединить строки или строковые переменные с помощью оператора +, как показано далее:

```python
>>> 'Release the kraken! ' + 'No, wait!'
'Release the kraken! 'No, wait!'
```

Если подобных действий много, избежать создания переходов на новую строку можно, заключив строки в скобки.

Python сам не добавляет пробелы при конкатенации строк, поэтому в более ранних примерах нам нужно было явно проставлять пробелы. Python **добавляет пробел между каждым аргументом выражения print()** и **символом новой строки** в конце.

### Размножаем строки с помощью символа *

Строку в Python можно размножить с помощью оператора *, вот так:

```python
>>>string = 'Hello' * 3
>>>print(string)
HelloHelloHello
```

Обратите внимание на то, что оператор * имеет более высокий приоритет, чем +, поэтому строка будет размножена до того, как к ней добавится символ перехода на новую строку.

Извлекаем символ с помощью символов [ ] Для получения одного символа из строки укажите его смещение в квадратных скобках после имени строки. Смещение первого (крайнего слева) символа равно 0, следующего — 1 и т. д. Чтобы не считать, смещение последнего (крайнего справа) символа можно указать как –1. В таком случае смещение последующих символов будет равно –2, –3 и т. д.:

```python
>>> letters = 'abcdefghijklmnopqrstuvwxyz'
>>> letters[0]
'a'
>>> letters[1]
'b'
>>> letters[-1]
'z'
>>> letters[-2]
'y'
>>> letters[25]
'z'
>>> letters[5]
'f'
```

Если вы укажете смещение, равное длине строки или больше (помните, смещения идут от 0 к длине –1), сгенерируется исключение:

```python
>>> letters[100]
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

Поскольку строки неизменяемы, вы не можете вставить символ непосредственно в строку или изменить символ по заданному индексу. Попробуем изменить слово Python на слово [Jython](https://ru.wikipedia.org/wiki/Jython) и посмотрим, что произойдет:

``` python
>>> name = 'Python'
>>> name[0] = 'J'
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

Вместо этого вам придется использовать комбинацию строковых функций (совсем скоро вы ее увидите), таких как **replace()** или **slice**:

``` python
>>> name = 'Python'
>>> name.replace('P', 'J')
'Jython'
>>> 'J' + name[1:]
'Jython'
```

### Извлекаем подстроки, используя разделение

Из строки можно извлечь подстроку (часть строки) с помощью разделения. Вы задаете разделение с помощью квадратных скобок, смещения начала подстроки начало и смещения конца подстроки конец, а также опционального размера шага между ними шаг. Некоторые из этих параметров могут быть пропущены. В подстроку будут включены символы, расположенные от точки, на которую указывает смещение начало, до точки, на которую указывает смещение конец. 

* Оператор [:] извлекает всю последовательность от начала до конца. 

* Оператор [начало :] извлекает последовательность с точки, на которую указывает смещение начало, до конца. 
* Оператор [: конец] извлекает последовательность от начала до точки, на которую указывает смещение конец минус 1. 
* Оператор [начало : конец] извлекает последовательность с точки, на которую указывает смещение начало, до точки, на которую указывает смещение конец минус 1. 
* Оператор [начало : конец : шаг] извлекает последовательность с точки, на которую указывает смещение начало, до точки, на которую указывает смещение конец минус 1, опуская символы, чье смещение внутри подстроки кратно шаг. 

Как и ранее, смещение слева направо определяется как 0, 1 и т. д., а справа налево — как –1, –2 и т. д. Если вы не укажете смещение начало, функция будет использовать в качестве его значения 0 (начало строки). Если не укажете смещение конец, его значением будет считаться конец строки. 

Пример:

```python
>>>s = 'Hello'
>>>s[:]
'Hello'
>>>s[1:]
'ello'
>>>s[:-2]
'Hel'
>>>s[1:3]
'el'
>>>s[0:4:2]
'Hl'
```

### Измеряем длину строки с помощью функции len()

До этого момента мы использовали специальные знаки, такие как +, для работы со строками. Но их не так уж и много. Теперь начнем использовать некоторые из встроенных функций Python: именованные фрагменты кода, которые выполняют определенные операции.

Функция len() подсчитывает количество символов в строке (на самом деле в коллекции):

```python
>>>len('I love Dota2') # Пробел - это тоже символ!
12
```

Про методы строк мы будем говорить в будущем, однако вы всегда можете посмотреть таблицу методов из предыдущего занятия.

## Списки

Списки особенно удобны для хранения в них объектов в определенном порядке, особенно если порядок или содержимое нужно будет изменить. В отличие от строк список изменяем: вы можете добавить новые элементы, перезаписать существующие и удалить ненужные. Одно и то же значение может встречаться в списке несколько раз.

### Создаем списки с помощью скобок []

```python
>>> empty_list = [ ]
>>> weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
```

### Создаем список или преобразуем в список с помощью функции list()

Аналогично тому, как мы можем создать число ```int()``` или строку ```str()```, мы можем создать список с помощью функции ```list()```.

``` python
>>>empty_list = list()
>>>empty_list
[]
```

Функция list() преобразует другие итерабельные типы данных (например, кортежи, строки, множества и словари) в списки. В следующем примере строка преобразуется в список, состоящий из односимвольных строк:

```python
>>> list('cat')
['c', 'a', 't']
```

*Примечание: к спискам применимы те же операции размножения, взятие по индексу и взятие подсписка, что и для строк*

### Немного про ссылки

**Важно:** раз списки являются **изменяемыми** объектами, то и устроены они немного по-другому. Вспоминаем прошлое занятие.

```python
>>>a = [1, 2, 3]
>>>print(id(a))
2508324297600
>>>b = [1, 2, 3]
>>>print(id(b))
2508365265600
```

Как мы видим при  создании новой переменной, которая ссылается на объект ```[1, 2, 3]``` всё время резервируется **новое место в памяти**, т. е. создается абсолютно новый объект.

Теперь очевидно, что список `b` в результате следующего кода останется без изменений, ведь мы будем менять только список `a`:

```python
>>>a = [1, 2, 3]
>>>b = [1, 2, 3]
>>>a[0] = 7 # Списки изменяемы, поэтому мы можем так писать
>>>print(b)
[1, 2 ,3]
```

А вот тут мы будем менять один и тот же объект, значит раз **переменные - это ссылки** на объект, то значение объекта поменяется и для `b`:

```python
>>>a = [1, 2, 3]
>>>b = a
>>>a[0] = 7
>>>print(b)
[7, 2 ,3]
```

### Методы работы со списками

| Метод                              | Что делает                                                   |
| ---------------------------------- | ------------------------------------------------------------ |
| **list.append**(x)                 | Добавляет элемент в конец списка                             |
| **list.extend**(L)                 | Расширяет список list, добавляя в конец все элементы списка L |
| **list.insert**(i, x)              | Вставляет на i-ый элемент значение x                         |
| **list.remove**(x)                 | Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует |
| **list.pop**([i])                  | Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент |
| **list.index**(x, [start [, end]]) | Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end) |
| **list.count**(x)                  | Возвращает количество элементов со значением x               |
| **list.sort**([key=функция])       | Сортирует список на основе функции                           |
| **list.reverse**()                 | Разворачивает список                                         |
| **list.copy**()                    | Поверхностная копия списка                                   |
| **list.clear**()                   | Очищает список                                               |

## Кортежи

Давайте сразу же рассмотрим один очевидный вопрос. Вы могли слышать два возможных варианта произношения слова tuple (кортеж). Какой же из них является правильным? Гвидо ван Россум, создатель языка Python, написал в Twitter:

«Я произношу слово tuple как too-pull по понедельникам, средам и пятницам и как tub-pull — по вторникам, четвергам и субботам. В воскресенье я вообще об этом не говорю :)».

### Создаем кортежи с помощью запятых и оператора ()

```python
>>>empty_tuple = ()
>>>empty_tuple
()
```

```python
>>>user = (12, 'John') # Пусть у нас будет user с каким-то ID и именем
>>>user
(12, 'John')
```

### Изменяем кортеж

Этого сделать вы не можете! Как и строки, кортежи неизменяемы. Но ранее вы уже видели на примере строк, что можно сконкатенировать (объединить) кортежи и создать таким образом новый кортеж:

```python
>>> t1 = ('Fee', 'Fie', 'Foe')
>>> t2 = ('Flop',)
>>> t1 + t2
('Fee', 'Fie', 'Foe', 'Flop')
```

Кстати, заметим, что в результате сложения кортежей (да и других объектов) получается **новый объект**.

```python
>>> t1 = ('Fee', 'Fie', 'Foe')
>>> t2 = ('Flop',)
>>> id(t1)
4365405712
>>> t1 += t2
>>> id(t1)
4364770744
```

*Примечание: а вот создание с помощью ```tuple()```, размножение с помощью *, взятие индекса - всё это работает также, как и в предыдущих примерах*

### Кортежи или списки? 

![img](https://res.cloudinary.com/practicaldev/image/fetch/s--IEGmO0OL--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/nlvtsqxxfsbpc9og0aka.jpg)

Вместо списков можно использовать кортежи, однако у них меньше возможностей — нет функций append(), insert() и т. д., поскольку кортеж не может быть изменен после создания. 

Почему бы тогда не работать всегда со списками вместо кортежей? 

* Кортежи занимают меньше места. 
* Вы не сможете уничтожить элементы кортежа по ошибке. 
* Вы можете использовать кортежи в качестве словарных ключей. 
* Именованные кортежи  могут служить более простой альтернативой объектам. 

