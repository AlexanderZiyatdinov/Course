# Функции

![img](https://cdn-images-1.medium.com/max/1600/1*5fIUIzQrNVPBzeQZiLM27w.gif)

Мы уже знакомы с условными конструкциями и циклами. Циклы зачастую помогают избежать дублирования кода и соблюсти в полной мере принцип **DRY**. 

Однако все примеры, что мы видели ранее, являются какими-то небольшими фрагментами. А что если нам необходимо использовать наш фрагмент несколько раз. Например, нам необходимо несколько раз проверить, а является ли число четным и при этом его запись содержит более 2 цифр? 

Одно из решений - создание **функций**. Функция - это некоторый именованный фрагмент кода, который находится отдельно от всего остального. Функция является некоторой подпрограммой внутри нашей программы.

Мы можем **определять** функцию, указав ей произвольное количество аргументов (в т. ч. ноль) и **вызывать** её, чтобы получить произвольное количество значений.

Функция, как и любая другая сущность в Python "поддерживает" выполнение утверждения - **Всё есть объект**

## Ключевое слово def

Мы можем определить функцию следующим образом:

```python
def foo():
    pass
```

Эта функция ничего не делает. У неё есть имя `foo` и даже возвращаемое значение `None` - т. е. ничего (В Python функция хоть как должна что-то вернуть, если она ничего не возвращает, то по умолчанию возвращает объект `None`)

Если мы хотим указать, что функция ничего не делает (вообще ничего), то для этого нам просто нужно указать `pass` (пропуск).

## Ключевое слово return

Если мы хотим, чтобы функция что-нибудь вернула, необходимо указать ключевое слово `return`, а затем указать объект(ы) для возвращения

```python
def foo():
    return 42

foo() # Вернет 42
```

## Добавим аргументов

Функция может принимать произвольное количество аргументов, перечислить мы их можем внутри скобок:

```python
def foo(arg1, arg2):
    result = arg1 + arg2
    return result

foo(5, 3) # Вернет 8
```

Как вы видите внутри функции мы можем создавать свои переменные и производить с ними действия.

## Зададим типизацию

С недавнего времени в Python появилась возможность указать тип принимаемых аргументов и возвращаемого значения. По сути - это просто некоторая подсказка для программиста, которая никак не влияет на выполнение кода. Если вы пишите в своем проекте, соблюдая правила компании или команды по оформлению типов, то это можно сделать так:

```python
def foo(arg1: int, arg2: int) -> int:
    result = arg1 + arg2
    return result

foo(5, 3) # Вернет 8
```

Все следующие примеры (как и 95% кода в мире) будут проиллюстрированы без указания типов.

## Позиционные аргументы

Python довольно гибко обрабатывает аргументы функций в сравнении со многими другими языками. Наиболее распространенный тип аргументов — это позиционные аргументы, чьи значения копируются в соответствующие параметры по порядку.

```python
def foo(arg1, arg2, arg3):
    result = (arg1 + arg2) * arg3
    return result

foo(5, 3, 2) # Вернет 16
```

## Ключевые аргументы

В **сигнатуре** функции мы можем указать ключевые параметры, к которым можем прибегнуть, чтобы избежать путаницы при использовании позиционных аргументов. Порядок может быть любым. 

```python
def foo(arg1, arg2, arg3):
    result = (arg1 + arg2) * arg3
    return result

foo(arg3=5, arg1=3, arg=2) # Вернет 30
```

Более того, мы можем комбинировать позиционные и ключевые аргументы:

```python
def foo(arg1, arg2, arg3):
    result = (arg1 + arg2) * arg3
    return result

foo(5, arg3=3, arg2=1) # Вернет 18
```

*Примечание:* дадим определение слову - **сигнатура**

**Сигнатура** функции пишется в самом начале. Она состоит из:

1. Ключевого слова `def`, которое говорит питону о том, что здесь мы начинаем писать новую функцию.
2. Названия функции.
3. Параметров, иначе говоря входных данных, необходимых для работы функции.

## Значение параметра по умолчанию

Мы можем указать значение для параметров функции по умолчанию, например так:

```python
def foo(arg1, arg2, arg3=5):
    result = (arg1 + arg2) * arg3
    return result

foo(2, 3) # Вернет 25
```

Но в любой момент, мы можем указать своё значение, и всё будет работать как прежде:

```python
def foo(arg1, arg2, arg3=5):
    result = (arg1 + arg2) * arg3
    return result

foo(2, 3, 4) # Вернет 20
```

Сначала принято писать позиционные аргументы, затем ключевые.

**Важно**: Значение параметров по умолчанию высчитывается, когда функция определяется, а не выполняется. Распространенной ошибкой новичков (а иногда и не совсем новичков) является использование изменяемого типа данных, таких как список или словарь, в качестве параметра по умолчанию.

Пример плохого кода:

```python
def bad_function(price, prices=[]):
    prices.append(price)
    print(prices)

bad_function(1) # Выведет: [1]
bad_function(3) # Выведет: [1, 3]
```

Чтобы решить эту проблему, можно использовать следующий инструмент (положить, что-то неизменяемое):

```python
def bad_function(price, prices=None):
    if prices is None:
    	prices.append(price)
    print(prices)

bad_function(1) # Выведет: [1]
bad_function(3) # Выведет: [3]
```

**Важно:** проверку на равенство значения `None` лучше всего писать именно так:

```python
object is None
```

Т. к. `None` - это [синглтон](https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)), т. е. существует только **один** экземпляр класса `None`.