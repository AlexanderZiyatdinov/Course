# Классы 2. Наследование. Полиморфизм. Магические методы и переопределение методов.

Итак, продолжим наш разговор с наследования. **Наследование** - это один из принципов ООП, позволяющий перенять часть логики и поведения от другого класса в наш текущий класс. По сути, хорошим примером наследования послужит вот такая иерархия:

![image-20210819190026865](C:\Users\79222\AppData\Roaming\Typora\typora-user-images\image-20210819190026865.png)

Давайте посмотрим на демонстративный вариант наследования (для того, чтобы указать, что класс наследуется от другого необходимо написать название класса в круглых скобках после его инициализации):

```python
class Parent:
    def parent_method(self):
        print('I am a parent')

class Child(Parent):
    pass

parent = Parent()
child = Child()
```

Мы создали два объекта. Первый типа `Parent`, а второй типа `Child`. Теперь немного поэкспериментируем:

```python
# Продолжение кода выше
print(isinstance(child, Parent))  # True
print(isinstance(child, Child))   # True

# Но
print(isinstance(parent, Child))  # False
```

Раз `Child` - это класс потомок класса `Parent`, то он наследует всё содержимое данного класса, т. е.

```python
# Продолжение кода выше
parent.parent_method()  # I am a parent
child.parent_method()  # I am a parent
```

Таким образом, мы можем использовать атрибуты и методы класса-родителя в классе потомке.

Вы определяете только то, что вам нужно добавить или изменить в новом классе, и этот код переопределяет поведение старого класса. Оригинальный класс называется родительским классом, суперклассом или базовым классом, а новый класс именуется потомком, подклассом или производным классом. Эти термины в объектно-ориентированном программировании взаимозаменяемы.

### Добавление новых методов

В классе-ребенке вы без особой опаски можете добавлять хоть сколько новых методов, при этом они будут доступны экземплярам только дочернего класса.

```python
class Parent:
    def parent_method(self):
        print('I am a parent')

class Child(Parent):
    def child_method(self):
        print('I am a child')

parent = Parent()
child = Child()

child.child_method() # Можно
child.parent_method() # Можно
parent.child_method() # Нельзя
parent.parent_method() # Можно
```

### Переопределение методов + super()

Помимо добавления новых методов, вы можете переопределять уже существующие, для этого стоит вам нужно просто задать новую логику вашему методу в дочернем классе:

```python
class Parent:
    def parent_method(self):
        print('I am a parent')

class Child(Parent):
    def child_method(self):
        print('I am a child')
    
    def parent_method(self):
        print('I am not a parent')

parent = Parent()
child = Child()

child.parent_method() # Выведет: "I am not a parent"
parent.parent_method() # Выведет: "I am a parent"
```

Более того, вы можете использовать конструкцию super(), которая позволит вам взять реализацию какого-либо метода из родительского класса, после чего вы можете дополнить новый метод уже своей реализацией:

```python
class Parent:
    def parent_method(self):
        print('I am a parent')

class Child(Parent):
    def child_method(self):
        print('I am a child')
    
    def parent_method(self):
        super().parent_method() # Вызввали работу родительского метода
        print('I am not a parent')

child = Child()
child.parent_method()

# Выведет:
"I am a parent"
"I am not a parent"
```

## Полиморфизм

**Полиморфизм** — одна из трех основных парадигм ООП. Если говорить кратко, полиморфизм — это способность обьекта использовать методы производного класса, который не существует на момент создания базового.

Полиморфизм зачастую достигается за счёт использования **интерфейсов** и **абстрактных классов**.

**Интерфейс** - это некая сущность, которая предопределяет классу используемые в нем методы и атрибуты.

**Абстрактный класс** - это некоторый класс, представляющий из себя каркас будущих классов.

### Абстрактный класс

Грубо говоря, это класс-шаблон. Он реализует функциональность только на том уровне, на котором она известна на данный момент. Производные же классы ее дополняют. Но, пора перейти от теории к практике.

```python
from abc import ABC, abstractmethod

class Human(ABC):
    @abstractmethod
    def say_hello(): # Теперь во всех классах потомках должен быть данный метод
        pass

class Parent(ABC):
    def say_hello(self):
        print('Hello')
        
    def parent_method(self):
        print('I am a parent')

class Child(Parent):
    def child_method(self):
        print('I am a child')
    
    def parent_method(self):
        print('I am not a parent')
```

Чтобы посмотреть на то, как именно Python ищет методы, необходимо написать специальную команду `__mro__` - method resolution order.

```python
# Продолжение кода сверху
Child.__mro__
(__main__.Child, __main__.Parent, abc.ABC, object) 
```

Как мы можем заметить, сначала поиск методов и атрибутов происходит в классе `Child`, затем в классе `Parent`, потом в абстрактном классе, и затем в классе `object`.

## Магические методы

> Источник: https://habr.com/ru/post/186608/

Что такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, `__init__` или `__lt__`). Ещё, они не так хорошо документированны, как хотелось бы. Все магические методы описаны в документации, но весьма беспорядочно и почти безо всякой организации. Поэтому, чтобы исправить то, что я воспринимаю как недостаток документации Питона, я собираюсь предоставить больше информации о магических методах, написанной на понятном языке и обильно снабжённой примерами. Надеюсь, это руководство вам понравится. Используйте его как обучающий материал, памятку или полное описание. Я просто постарался как можно понятнее описать магические методы.



